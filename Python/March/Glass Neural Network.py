import random
win_pl = 0 #ну победы соответственно нейронки
win_nr = 0

stakan_0 = [0]
stakan_1 = [1,1,1,1,1,2,2,2,2,2]
stakan_2 = [1,1,1,1,1,2,2,2,2,2]    #создание стаканов
stakan_3 = [1,1,1,1,1,2,2,2,2,2]
stakan_4 = [1,1,1,1,1,2,2,2,2,2]
stakan_5 = [1,1,1,1,1,2,2,2,2,2]
stakan_6 = [1,1,1,1,1,2,2,2,2,2]
stakan_7 = [1,1,1,1,1,2,2,2,2,2]
stakan_8 = [1,1,1,1,1,2,2,2,2,2]
stakan_9 = [1,1,1,1,1,2,2,2,2,2]
stakan_10 = [1,1,1,1,1,2,2,2,2,2]
list_bumag = []  #список для запоминания карточек, которые мы вытащили со стаканов
kolvo_palochek = 10
hod = random.randint(0, 1)
def start_initialization(stakan_0, stakan_1, stakan_2, stakan_3,stakan_4,stakan_5,stakan_6,stakan_7, stakan_8, stakan_9, stakan_10, list_bumag, win_pl, win_nr, hod):
    global kolvo_palochek

    stakans = [stakan_0, stakan_1, stakan_2, stakan_3, stakan_4, stakan_5, stakan_6, stakan_7, stakan_8, stakan_9, stakan_10]

    def game_1_round(): #первый ход(определяется рандомом) для дальнейшего определения ходов
        global kolvo_palochek, win_pl, win_nr, hod


        if hod == 0: # нулевой ход - ход игрока
            hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            if hod_igroka > 2:
                print("ээээ, это не одна и не две, давай переигрывай, для тупых что ли написал?")
                hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            kolvo_palochek -= hod_igroka
            hod = 1
            print("Палочек осталось " + str(kolvo_palochek) + " штук")# опрелеляем кто победил, а кто проиграл
            if kolvo_palochek == 1: # ну если побеждает игрок, то победы нейронки понижаются на еденицу:) вроде все логично
                win_pl += 1            # а нам для победы, точнее для правильной работы, нужно 5 побед подряд


        if hod == 1:   # первичный ход - ход нейронки
            hod_ner = random.choice(random.choice(stakans))
            kolvo_palochek -= hod_ner
            print("Нейронка вытащила палочку.., ну или палочки, их осталось " + str(kolvo_palochek) + " штук")
            hod = 0

            if kolvo_palochek == 1: # определяем кто победил, а кто проиграл
                win_nr += 1



    def nexts_rounds():
        global hod, list_bumag, kolvo_palochek, win_pl, win_nr

        if hod == 0:
            hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            if hod_igroka > 2:
                print("ээээ, это не одна и не две, давай переигрывай, для тупых что ли написал?")
                hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))

            kolvo_palochek -= hod_igroka
            print("Палочек осталось " + str(kolvo_palochek) + " штук")
            hod = 1

            if kolvo_palochek == 1:
                win_pl += 1

        if hod == 1:
            hod_ner = random.choice(random.choice(stakans))
            kolvo_palochek -= hod_ner
            print("Нейронка вытащила палочку.., ну или палочки, их осталось " + str(kolvo_palochek) + " штук")
            hod = 0

            if kolvo_palochek == 1:
                win_nr += 1


    while (win_nr - win_pl) != 5:
        while kolvo_palochek != 0:
            if kolvo_palochek == 10: #определение первого хода
                game_1_round()
            elif kolvo_palochek < 10:
                nexts_rounds() #если первых ход уже определен, то мы запускаем последующие раунды, в которых уже известно кто ходит:)
                if kolvo_palochek <= 1:
                    #hod = random.randint(0, 1) #пока что ход после первой игры будет определяться рандомно, ибо я пока не придумал как узнавать то, кто выиграл в прошлом раунде
                    start_initialization(stakan_0, stakan_1, stakan_2, stakan_3,stakan_4,stakan_5,stakan_6,stakan_7, stakan_8, stakan_9, stakan_10, list_bumag, win_pl, win_nr, hod)
                    #нужно будет создать еще раз переменные со стаканами, победами и прочим, чтобы сохранить результаты прошолой игры(количество побед и т.д.)
start_initialization(stakan_0, stakan_1, stakan_2, stakan_3,stakan_4,stakan_5,stakan_6,stakan_7, stakan_8, stakan_9, stakan_10, list_bumag, win_pl, win_nr, hod)
# Нейросеть из стаканов

#Правила игры
#"""
#На столе 11 палочек, два игрока ходят по очереди. За каждый ход можно взять 1 или 2 палочки.
#Проиграл тот, кто взял последнюю палочку.
#
#Пользователь играет против компьютера. Первый ход определяется случайным образом, далее первым ходит игрок,
#проигравший в предыдущем раунде.
#
#Игра IRL:
#На столе стоят 10 стаканов (можно 11, но стакан для хода на последнюю палочку никогда не используется,
#т.к. в этом нет смысла). В каждом стакане ("нейроне") содержится по 5 бумажек с цифрами 1 и 2.
#Каждый свой ход "нейросеть" выбирает из стакана с номером, соответствующим числу палочек на столе,
#случайную бумажку с цифрой, затем берёт со стола количество палочек == числу на бумажке, затем передаёт
#ход игроку.
#
#В случае проигрыша "нейросети", из всех стаканов, которые принимали участие в раунде, убирается бумажка,
#которую "нейронка" выбрала для хода. В случае выигрыша - добавляется новая бумажка с тем же значением, что
#у использованной.
#
#Если в "нейроне" остаётся последняя бумажка любого значения, она не удаляется при следующей
#неудачной итерации -- на случай, если "нейросеть" попала в цикл неудачных решений на других "нейронах".
#Поэтому бумажка с неправильным решением удаляется только после 10 подряд неудачных раундов.
#Если несколько "нейронов" одновремено принимают неверные решения, удаляются не все сразу, а нейрон
#с минимальным номером, через 10 неудач -- следующий минимальный и т.д..
#
#Выполнение программы продолжается до 5 подряд побед "нейросети". После победы "нейросеть" показывает
#содержимое стаканов -- сколько и каких бумажек в них содержится, какова вероятность принятия того или
#иного решения в каждом "нейроне".
#
#Использование сторонних библиотек (pybrain, pygame, numpy и т.п.) запрещено. Можно использовать только random."""

