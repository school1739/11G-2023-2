# -*- coding: cp1251 -*-
#дичь какая-то с запуском была, нашел решение дописать какую-то строчку с указанием кодировки, вроде помогло

#P.s можно хотя бы не двоечку:)... времени убил уйму, часов 6-8, но шо поделать, не получилось довести до ума обучение:((( ломается вся игра, хотя все в теории должно работать
#видел решение Ходины Анны, но это непонятная и нечитаемая фигня(без единой функции и 600 строк кода о_О), работает наверное, но лучше своя двойка-тройка, зато опыт офигенный получил

import random
win_pl = 0 #количество побед игрока
win_nr = 0 #количество побед соответственно нейронки

stakan_0 = [1]
stakan_1 = [1,1,1,1,1,2,2,2,2,2]
stakan_2 = [1,1,1,1,1,2,2,2,2,2]    #создание стаканов
stakan_3 = [1,1,1,1,1,2,2,2,2,2]
stakan_4 = [1,1,1,1,1,2,2,2,2,2]
stakan_5 = [1,1,1,1,1,2,2,2,2,2]
stakan_6 = [1,1,1,1,1,2,2,2,2,2]
stakan_7 = [1,1,1,1,1,2,2,2,2,2]
stakan_8 = [1,1,1,1,1,2,2,2,2,2]
stakan_9 = [1,1,1,1,1,2,2,2,2,2]
stakan_10 = [1,1,1,1,1,2,2,2,2,2]

list_bumag_1 = []  #список для запоминания карточек, которые мы вытащили со стаканов(нейронов)
list_bumag_2 = []
kolvo_palochek = 11 #количество палочек
hod = random.randint(0, 1) #определяем первый ход

def start_initialization(stakan_0, stakan_1, stakan_2, stakan_3,stakan_4,stakan_5,stakan_6,stakan_7, stakan_8, stakan_9, stakan_10, list_bumag, win_pl, win_nr, hod): #основная функция игры
    global kolvo_palochek  #глобалим палочки:)
    kolvo_palochek = 11

    stakans = [stakan_0, stakan_1, stakan_2, stakan_3, stakan_4, stakan_5, stakan_6, stakan_7, stakan_8, stakan_9, stakan_10] #список стаканов, внутри которых списки с бумажками
    #функции функции

    def game_1_round(): #первый ход(определяется рандомом) для дальнейшего определения ходов
        global kolvo_palochek, win_pl, win_nr, hod


        if hod == 0: # нулевой ход - ход игрока
            hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            while hod_igroka > 2:
                print("ээээ, это не одна и не две, давай переигрывай, для тупых что ли написал?") #не ну это рил для тупых кто читать не умеет
                hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            kolvo_palochek -= hod_igroka
            hod = 1
            print("Палочек осталось " + str(kolvo_palochek) + " штук")# опрелеляем кто победил, а кто проиграл
            if kolvo_palochek == 1: # ну если побеждает игрок, то победы нейронки повышаются на еденицу:) вроде все логично
                win_pl += 1            # а нам для победы, точнее для правильной работы, нужно 5 побед подряд, то есть их разность должна быть равна 5(да, я знаю
                                                                                        #что может быть и такое, что нейронка выигрывает 2 раза, потом игрок 1 раз, потом нейронка 4 и все, разность равна 5, хотя это не 5 игр подряд, но... пока только так)

        if hod == 1:   # первичный ход - ход нейронки

            n_st = stakans[kolvo_palochek - 1] #определяем какой стакан в игре для хода нейронки
            hod_ner = random.choice(n_st) #выбираем рандомное значение со стакана

            kolvo_palochek -= hod_ner
            print("Нейронка вытащила " + str(hod_ner) + " палочку, ну или палочки. Их осталось " + str(kolvo_palochek) + " штук")
            hod = 0

            if kolvo_palochek == 1: # определяем кто победил, а кто проиграл
                win_nr += 1



    def nexts_rounds():  #функция для послдующих мини-раундов после первого определения хода
        global hod, list_bumag, kolvo_palochek, win_pl, win_nr

        if hod == 0:  #определяем чей сейчас ход
            hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))
            while hod_igroka > 2:
                print("ээээ, это не одна и не две, давай переигрывай, для тупых что ли написал?") #вставочка для тупых:)
                hod_igroka = int(input("Сколько палочек вы хотите вытащить?(от 1 до 2) отсталось " + str(kolvo_palochek) + " штук - "))

            kolvo_palochek -= hod_igroka  #обновляем значение палочек, которые лежат на столе
            print("Палочек осталось " + str(kolvo_palochek) + " штук")
            hod = 1

            if kolvo_palochek < 1:  #считаем победы игрока
                win_pl -= 1

            if kolvo_palochek < 1:
                if hod == 0:
                    print("В этом раунде победил игрок")  #также определение того, кто победил, а кто проиграл, но только для пользователя
                if hod == 1:
                    print("Победила нейронка")

        if hod == 1:  #определение хода для последующих раундов
            n_st = stakans[kolvo_palochek - 1]
            hod_ner = random.choice(n_st)
            kolvo_palochek -= hod_ner
            print("Нейронка вытащила " + str(hod_ner) + " палочку, ну или палочки. Их осталось " + str(kolvo_palochek) + " штук")
            hod = 0

            if kolvo_palochek <= 1:
                win_nr -= 1

            if kolvo_palochek <= 1:
                if hod == 0:     #опеределение того, кто победил, а кто проиграл
                    print("В этом раунде победил игрок")
                    hod_ner = 1
                if hod == 1:
                    print("Победила нейронка")
                    hod_ner = 0 #на всякий




    def obychenie(): #ну пожалуй это самое сложное.... по-любасу щас приедется думать че-то с глобализацией стаканов(ибо тогда значения изменяться не будут, но если это сделать, то жопа будет для всех вводимых аргументов по типу "stakan_1" и т.д. для других функций....) и эксперементировать с этим:((((
        global stakan_1, stakan_2, stakan_3, stakan_4, stakan_5, stakan_6, stakan_7, stakan_8, stakan_9, stakan_10, kolvo_palochek, hod, list_bumag_1, list_bumag_2, hod_ner, stakans
        while kolvo_palochek > 1:
            list_bumag_1.append(kolvo_palochek)   #обучение не работает...
            list_bumag_1.append(hod_ner)
            list_bumag_2.append(list_bumag_1)
            list_bumag_1.clear()
            if win_nr < win_nr: # немного изменю условие, что если игрок победил больше, чем нейронка, то ходит нейронка, ибо без понятия как сделать по другому, пусть хоть так будет
                for i in list_bumag_2:
                    for q in list_bumag_1:
                        in_n = list_bumag_2[i][0]
                        delete_cards = list_bumag_2[i][1]
                        for d in stakans[in_n]:
                            if d == delete_cards:
                                stakans[in_n].remove(d)  #и щас назрел очень хороший вопрос... а где это вызывать вообще?..




    while (win_nr - win_pl) != 5: #ну типо усоловие задачи
        kolvo_palochek = 11
        while kolvo_palochek != 0:
            if kolvo_palochek == 11: #определение первого хода
                game_1_round()

                #obychenie()

            elif kolvo_palochek < 11:
                nexts_rounds() #если первых ход уже определен, то мы запускаем последующие раунды, в которых уже известно кто ходит:)

                #obychenie()

                if kolvo_palochek <= 1:
                    #check_you - доп условие, которое позволяет остановить или продолжить игру взависимости от его желания с выведением содержимого всех стаканов
                    #сделал чтобы проверять работает ли код, ибо играть 3 часа до 5 побед подряд - не особо хочется:(
                    check_you = int(input("Вы хотите продолжить обучать нейросеть путем дальнейших игр? (0 - нет, будет выведено содержимое стаканов. 1 - да, игра продолжится, содержимое стаканов отображаться не будет)"))
                    if check_you == 0: #если пользователю надоело учить нейросеть, то он выходит из программы и видит результат обучения
                        #то есть видит количество побед игрока, нейросети, ну и содержимое каждого стакана
                        print(win_pl," -победы игрока ", win_nr, " - победы  игрока ", stakans, " - содержимое всех стаканок, пасиб за игру:)")
                        break

                    if check_you != 0: #если же ему не надоело в это играть, то он продолжает учить нейросеть, при этом содержимое стаканов и прочее - не выводится
                        kolvo_palochek = 11
                        while kolvo_palochek <= 1:
                            if kolvo_palochek == 11:  # определение первого хода
                                game_1_round()
                                #obychenie()
                            elif kolvo_palochek < 11: # если первых ход уже определен, то мы запускаем последующие раунды, в которых уже известно кто ходит:)
                                nexts_rounds()
                                #obychenie() амм, спустя 3 минуты сломалось абсолютно все:(

                                #hod = random.randint(0, 1) #пока что ход после первой игры будет определяться рандомно, ибо я пока не придумал как узнавать то, кто выиграл в прошлом раунде



start_initialization(stakan_0, stakan_1, stakan_2, stakan_3,stakan_4,stakan_5,stakan_6,stakan_7, stakan_8, stakan_9, stakan_10, list_bumag_1, win_pl, win_nr, hod) #начало игры



# Нейросеть из стаканов# Нейросеть из стаканов

#Правила игры
#"""
#На столе 11 палочек, два игрока ходят по очереди. За каждый ход можно взять 1 или 2 палочки.
#Проиграл тот, кто взял последнюю палочку.
#
#Пользователь играет против компьютера. Первый ход определяется случайным образом, далее первым ходит игрок,
#проигравший в предыдущем раунде.
#
#Игра IRL:
#На столе стоят 10 стаканов (можно 11, но стакан для хода на последнюю палочку никогда не используется,
#т.к. в этом нет смысла). В каждом стакане ("нейроне") содержится по 5 бумажек с цифрами 1 и 2.
#Каждый свой ход "нейросеть" выбирает из стакана с номером, соответствующим числу палочек на столе,
#случайную бумажку с цифрой, затем берёт со стола количество палочек == числу на бумажке, затем передаёт
#ход игроку.
#
#В случае проигрыша "нейросети", из всех стаканов, которые принимали участие в раунде, убирается бумажка,
#которую "нейронка" выбрала для хода. В случае выигрыша - добавляется новая бумажка с тем же значением, что
#у использованной.
#
#Если в "нейроне" остаётся последняя бумажка любого значения, она не удаляется при следующей
#неудачной итерации -- на случай, если "нейросеть" попала в цикл неудачных решений на других "нейронах".
#Поэтому бумажка с неправильным решением удаляется только после 10 подряд неудачных раундов.
#Если несколько "нейронов" одновремено принимают неверные решения, удаляются не все сразу, а нейрон
#с минимальным номером, через 10 неудач -- следующий минимальный и т.д..
#
#Выполнение программы продолжается до 5 подряд побед "нейросети". После победы "нейросеть" показывает
#содержимое стаканов -- сколько и каких бумажек в них содержится, какова вероятность принятия того или
#иного решения в каждом "нейроне".
#
#Использование сторонних библиотек (pybrain, pygame, numpy и т.п.) запрещено. Можно использовать только random."""

